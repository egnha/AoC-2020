# [Day 14](https://adventofcode.com/2020/day/14): Docking Data


```python
with open("../data/14.txt", "r") as f:
    code = f.read()
```

## Part 1


```python
import re

class Memory(dict):
    """Memory as a dictionary of address-value pairs."""
    
    @classmethod
    def write(cls, registers, code):
        """Write to memory by running code."""
        cls.registers = registers
        mem = cls()  # Must be named "mem"
        exec(cls.transform(code))
        return mem
    
    def registers(self, addr, val):
        """Generate address-value pairs to write; assign dynamically."""
    
    @staticmethod
    def transform(code):
        """Enable nonstandard mask assignment."""
        return re.sub(r"mask = (.*)\n", r"mem.mask = '\1'\n", code)
    
    def setmask(self, val):
        self._mask = self.asint("1" if x == "X" else "0" for x in val)
        self._places = [i for i, x in enumerate(reversed(val)) if x == "X"]
        self._overwrite = self.asint("0" if x == "X" else x for x in val)
    
    mask = property(fset=setmask)
    
    @staticmethod
    def asint(x):
        return int("".join(x), 2)

    def __setitem__(self, addr, val):
        """Write values to memory."""
        for a, v in self.registers(addr, val):
            super().__setitem__(a, v)
        
    def __iter__(self):
        return iter(super().values())

def registers(self, addr, val):
    """Apply bitmask to memory values."""
    yield addr, (val & self._mask) | self._overwrite

assert 7817357407588 == sum(Memory.write(registers, code))
```

## Part 2


```python
from itertools import product
from operator import lshift

def registers2(self, addr, val):
    """Decode memory addresses."""
    addr = (addr | self._overwrite) & (BITS36 ^ self._mask)
    for bits in product((0, 1), repeat=len(self._places)):
        yield addr | sum(map(lshift, bits, self._places)), val

BITS36 = 2**36 - 1

assert 4335927555692 == sum(Memory.write(registers2, code))
```
